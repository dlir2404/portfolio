---
title: "MySQL Index v√† Filesort: T·∫°i sao MySQL kh√¥ng c·∫ßn sort khi ORDER BY primary key?"
summary: "Kh√°m ph√° b√≠ m·∫≠t ƒë·∫±ng sau vi·ªác MySQL tr√°nh filesort khi query v·ªõi WHERE city='HCM' ORDER BY id LIMIT 10. T√¨m hi·ªÉu v·ªÅ clustered index, secondary index v√† covering index trong InnoDB."
publishedAt: "2025-10-10"
readTime: "8 min read"
tags: ["MySQL", "Database", "Performance"]
featured: false
image: "/images/blogs/mysql-index-filesort/cover.png"
author: "Larry Vu"
---

## C√¢u h·ªèi ƒë·∫∑t ra: T·∫°i sao MySQL kh√¥ng d√πng filesort?

H√¥m nay m√¨nh g·∫∑p m·ªôt t√¨nh hu·ªëng th√∫ v·ªã khi ƒëang debug performance cho m·ªôt query MySQL. C√≥ m·ªôt table `users` v·ªõi c·∫•u tr√∫c ƒë∆°n gi·∫£n:

```sql
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    city VARCHAR(50),
    INDEX idx_city (city)
);
```

Khi ch·∫°y query sau:

```sql
EXPLAIN SELECT * FROM users 
WHERE city = 'HCM' 
ORDER BY id 
LIMIT 10;
```

K·∫øt qu·∫£ `EXPLAIN` kh√¥ng c√≥ t·ª´ **"Using filesort"** trong c·ªôt `Extra`. ƒêi·ªÅu n√†y kh√° l·∫° v√¨ m√¨nh expect MySQL ph·∫£i sort theo `id` sau khi filter theo `city`. V·∫≠y **t·∫°i sao MySQL kh√¥ng c·∫ßn filesort?**

## B√≠ m·∫≠t ƒë·∫±ng sau: InnoDB Secondary Index Structure

C√¢u tr·∫£ l·ªùi n·∫±m ·ªü c√°ch InnoDB t·ªï ch·ª©c **secondary index**. Theo [MySQL Documentation](https://dev.mysql.com/doc/refman/8.4/en/innodb-index-structure.html):

> **"Each secondary index entry contains the primary key columns for the row, as well as the columns specified in the index."**

ƒêi·ªÅu n√†y c√≥ nghƒ©a l√† khi ch√∫ng ta t·∫°o index `idx_city (city)`, InnoDB **t·ª± ƒë·ªông** th√™m primary key v√†o cu·ªëi:

```sql
-- Nh·ªØng g√¨ ch√∫ng ta ƒë·ªãnh nghƒ©a:
INDEX idx_city (city)

-- Nh·ªØng g√¨ InnoDB th·ª±c s·ª± l∆∞u tr·ªØ:
INDEX idx_city (city, id)  -- id ƒë∆∞·ª£c th√™m t·ª± ƒë·ªông!
```

## Visualizing Index Structure

H√£y t∆∞·ªüng t∆∞·ª£ng data trong `idx_city` ƒë∆∞·ª£c s·∫Øp x·∫øp nh∆∞ th·∫ø n√†y:

<Image
  src="/images/blogs/mysql-index-filesort/img1.png"
  alt="index data"
  width={1024}
  height={1536}
  className="w-1/2"
/>

Khi query `WHERE city = 'HCM' ORDER BY id`, MySQL:
1. S·ª≠ d·ª•ng index `idx_city` ƒë·ªÉ t√¨m t·∫•t c·∫£ rows c√≥ `city = 'HCM'`
2. **C√°c rows n√†y ƒë√£ ƒë∆∞·ª£c s·∫Øp x·∫øp theo `id`** trong index r·ªìi!
3. Ch·ªâ c·∫ßn ƒë·ªçc tu·∫ßn t·ª± v√† l·∫•y 10 rows ƒë·∫ßu ‚Üí **Kh√¥ng c·∫ßn filesort**

## Th√≠ nghi·ªám 1: ORDER BY column kh√°c

B√¢y gi·ªù th·ª≠ query v·ªõi `ORDER BY name`:

```sql
EXPLAIN SELECT * FROM users 
WHERE city = 'HCM' 
ORDER BY name 
LIMIT 10;
```

**K·∫øt qu·∫£:** `Extra: Using filesort`

**T·∫°i sao?** V√¨ secondary index `idx_city` ch·ªâ ch·ª©a `(city, id)`, kh√¥ng c√≥ `name`. MySQL ph·∫£i:
1. T√¨m matching rows t·ª´ index
2. **Fetch data t·ª´ clustered index** ƒë·ªÉ l·∫•y `name`
3. **Sort theo `name`** ‚Üí Filesort!

## Th√≠ nghi·ªám 2: Covering Index - Lo·∫°i b·ªè filesort

T·∫°o **covering index** bao g·ªìm t·∫•t c·∫£ columns c·∫ßn thi·∫øt:

```sql
CREATE INDEX idx_city_name ON users (city, name);
```

B√¢y gi·ªù ch·∫°y l·∫°i query:

```sql
EXPLAIN SELECT * FROM users 
WHERE city = 'HCM' 
ORDER BY name 
LIMIT 10;
```

**K·∫øt qu·∫£:** `Extra: Using index`

**Magic!** üé©‚ú® Index `idx_city_name` c√≥ c·∫•u tr√∫c th·ª±c t·∫ø l√† `(city, name, id)`, ƒë∆∞·ª£c s·∫Øp x·∫øp ho√†n h·∫£o cho query n√†y.

## Double Lookup vs Covering Index

### Scenario 1: Regular Secondary Index
```sql
-- Index: idx_city (city, id)
SELECT * FROM users WHERE city = 'HCM' ORDER BY name;
```

**Flow:**
1. Scan `idx_city` ‚Üí T√¨m ƒë∆∞·ª£c c√°c `id` matching
2. **Double lookup:** Truy c·∫≠p clustered index ƒë·ªÉ l·∫•y full row data
3. **Sort** c√°c rows theo `name`
4. Return k·∫øt qu·∫£

### Scenario 2: Covering Index
```sql
-- Index: idx_city_name (city, name, id)
SELECT * FROM users WHERE city = 'HCM' ORDER BY name;
```

**Flow:**
1. Scan `idx_city_name` ‚Üí Data ƒë√£ sorted theo `(city, name)`
2. **Kh√¥ng c·∫ßn double lookup** v√¨ t·∫•t c·∫£ data ƒë√£ c√≥ trong index
3. **Kh√¥ng c·∫ßn sort** v√¨ data ƒë√£ sorted
4. Return k·∫øt qu·∫£ tr·ª±c ti·∫øp

## Th√≠ nghi·ªám 3: Khi Covering Index "b·ªã ph√°"

Gi·∫£ s·ª≠ ch√∫ng ta th√™m column `age`:

```sql
ALTER TABLE users ADD COLUMN age INT;
```

B√¢y gi·ªù query `SELECT *` s·∫Ω bao g·ªìm c·∫£ `age`:

```sql
EXPLAIN SELECT * FROM users 
WHERE city = 'HCM' 
ORDER BY name 
LIMIT 10;
```

**K·∫øt qu·∫£:** `Extra: NULL` (kh√¥ng c√≥ g√¨ c·∫£!)

**So s√°nh v·ªõi Scenario 2:** 
- **Scenario 2:** `Extra: Using index` (covering index, kh√¥ng c·∫ßn double lookup)
- **Scenario 3:** `Extra: NULL` (c·∫ßn double lookup nh∆∞ng kh√¥ng c·∫ßn filesort)

**T·∫°i sao kh√°c nhau?** 
1. **Covering index b·ªã m·∫•t:** Index `idx_city_name` kh√¥ng ch·ª©a column `age`, n√™n MySQL kh√¥ng th·ªÉ return data tr·ª±c ti·∫øp t·ª´ index
2. **Sort order ƒë∆∞·ª£c preserve:** MySQL scan index `idx_city_name` theo th·ª© t·ª± `(city, name)` 
3. **Double lookup cho missing columns:** V·ªõi m·ªói row t·ª´ index, MySQL lookup v√†o clustered index ƒë·ªÉ l·∫•y `age`
4. **Kh√¥ng c·∫ßn filesort:** V√¨ rows ƒë√£ ƒë∆∞·ª£c fetch theo ƒë√∫ng th·ª© t·ª± sort t·ª´ index scan

**Trade-off:** M·∫•t **"Using index"** optimization nh∆∞ng v·∫´n gi·ªØ ƒë∆∞·ª£c **sort efficiency**!

## Key Takeaways

### 1. Secondary Index = Index Columns + Primary Key
InnoDB t·ª± ƒë·ªông append primary key v√†o cu·ªëi m·ªçi secondary index.

### 2. B-Tree Sort Order
B-trees l∆∞u tr·ªØ data theo th·ª© t·ª± **ascending** m·∫∑c ƒë·ªãnh, tr·ª´ khi explicit ƒë·ªãnh nghƒ©a `DESC`.

### 3. Covering Index Magic
Khi index ch·ª©a **t·∫•t c·∫£** columns needed, MySQL c√≥ th·ªÉ tr·∫£ k·∫øt qu·∫£ tr·ª±c ti·∫øp m√† kh√¥ng c·∫ßn access clustered index.

### 4. Filesort Conditions
MySQL d√πng filesort khi:
- ORDER BY column kh√¥ng match v·ªõi index order
- C·∫ßn fetch additional columns kh√¥ng c√≥ trong index
- Index kh√¥ng cover ƒë·ªß columns cho query

## Best Practices

1. **Design indexes theo query patterns:** N·∫øu th∆∞·ªùng query `WHERE A ORDER BY B`, t·∫°o index `(A, B)`

2. **Consider covering indexes:** Cho c√°c queries hot, t·∫°o index ch·ª©a t·∫•t c·∫£ columns needed

3. **Monitor EXPLAIN plans:** Lu√¥n check `Extra` column ƒë·ªÉ spot filesort

4. **Understand the trade-offs:** More indexes = faster reads nh∆∞ng slower writes

## K·∫øt lu·∫≠n

MySQL InnoDB c√≥ nh·ªØng optimization r·∫•t th√¥ng minh ·ªü index level. Hi·ªÉu r√µ c√°ch secondary indexes work s·∫Ω gi√∫p b·∫°n design schemas v√† queries hi·ªáu qu·∫£ h∆°n. Remember: **secondary index kh√¥ng ch·ªâ l√† nh·ªØng g√¨ b·∫°n define, m√† c√≤n bao g·ªìm primary key!**

L·∫ßn t·ªõi khi th·∫•y query kh√¥ng c√≥ "Using filesort" m√† b·∫°n expect c√≥, h√£y nh·ªõ ƒë·∫øn b√†i vi·∫øt n√†y nh√©! üòâ
